


Chapter 1

python is translated programming language

it is powerful,versatile, still simple syntax

to output data- print("Hello All")

to input data example- name = input("What is your name?")

to output data-  print("Hello, " + name + ", nice to meet you")

to take numerical data, use data type, example- 
year= int(input("when were you born"))

we can use conditional statements such as- if, else, elif,

we can use relational operators such as >,>=,<,<=, etc
conditional operators ==

if and else condition example-

number = int(input("enter a number"))

if number < 0:
print("Negative number!")

else:
print("Positive number!")

print("Thankyou")


there needs to be if statement before elif, else statement

elif statement is used for connecting all the conditions and checking the correct one from all of them, the 'if' and 'else' statement breaks as one block, means it will be only applicable for particular condition and not for all conditions in the code. 
elif statement example-

animal = input("which animal?")

if animal == "dog" or animal == "cat":
print("it is a good animal")

elif animal == "lion"
print("it is not a good animal")

else:
print("I dont know about this animals")


the upper case and lowercase matters, 

we use "and" operator 
 the and operator is true only if 'a' and 'b' are true

 in 'or' operator only one condition needs to be true

 example of and operator-

    age = int(input("enter your age"))
    if age >= 18 and age <= 40:
    print("you can enter")
    elif age < 18:
    print("you are too young")
    else:
    print("you are too old")

 nested conditions - it has condition statement inside another condition statement

 example-

age = int(input("enter your age"))

if age >= 18:
   print("you cann enter")

   if age >= 65:
    print("you wil get a senior citizen discount")
   else:
    print("you will not get a discount")

else:
   print("you are too young to enter")

we use loop for repeating the block multiple times and we provide a condition to end the loop
repetition with while(True) statement is continued until break is encountered

example-

while True:
  number = int(input("enter a number, 0 to stop")
  
  if number == 0:
     break

  print("The square of",number,"is",(number * number))

print("Thankyou for using this square program")

   2nd example of loop -


counter = 1

   while counter<5:
   print("Hello")

   counter += 1
   print(f"the counter is now{counter}")

 print("All done with the loop")   

 infinte loop is a loop which is not terminated
 it keeps on repeating, so to end an infinite loop we use a condition

 the variables should be defined outside the loop before using them in loop

number += 1 is same as number = number + 1

break statement terminates the loop
it exists the loop immediately


break statement example-

number = 1

while number < 10:
 print(number)

 if number == 5:
    break

  number += 1

print("The number is now",(number))

In the above example the output is 1 2 3 4 5 and print will display - the number is now 5


The continue statement continues to execute the loop by skipping the conditioned statement.

example-

number = 1

while number < 10:
  number +=1
   if number % 3 == 0:
   continue

   print(f"The number is now {number}")

   In the aabove example the output will be from 2 to 10 and it will skip the numbers which are divisible by 3

nested loop is the loop inside a loop

example of infinite loop-
,
while True:
print("hello")
  while True:
  print("Hello again")
  break


  in above example the loop is infinite and it will print hello and hello again, one after another repetetively


string has characters, each character in the string has index
we can extract single charcter by its index
the first character is stored at position 0

       
example of string-

name = input("Give a name: ")

first = name[0]
second = name[1]
last = name[len(name) - 1]
print("The first character is {first}")
print("The second character is {second}")
print('The last character is {last}")

if we want all the characters then we can use a  loop and give the variable smaller than the length of the name variable

example-    

name = input("Enter a name")
 index = 0
 while index < len(name):
 print(name{index})
 index += 1 

 this program will print all the characters as a string.
if we entered name as Pranav then it will print P r a n a v

it also takes space as a string

we can also access the characters from end by using -1 , -2 etc

substring is a string containing characters from a main string

slicing means accessing a specific subset of elements from a sequence. it allows you to extract parts of a sequence by specifying a range.   
slicing syntax- mystring[begin : end]
example- string my_string = "Exemplary";
my_string.substring(2,6) == "empl" 

in above example the e is at position 2 and l is at position 5, so 2,6 shows the character from 2nd position to 5th position as 6th position is exclusive
example of substring - 

name = input("Enter a name: ")
first_three = name[0 : 3]

print("first_three)

 so here the output wll be the first thre characters of name entered by user

we use "in" operator to check whether the substring is in the main string


example-

sentence = input("Enter a sentence")

if "cat" in sentence:
print("you are talking about cats")

else:
print("Your are talking about something else")


For Finding substring we can use variable.find("enter the string to find")

example-

sentence = input("Give a sentence")

if "cat" in sentence:
print("you are talking about cats")
index_of_cat = sentence.find("cat")
print(f"it starts at {index_of_cat}")
else:
print("you are talking about something else than cats")

Functions are defined as 
def function_name():
function code

example-
def say_hello():
print("hello all")
print("nice to meet you")

def ask_name():
name = input("enter your name")
print("hello",+"name"+"!")

say_hello()
ask_name()


we can define a variable inside a function  
Example-

def shout(message):
print("message")

shout(hello)
shout(hi)

Function example with using loop

def repeat_hello(number):
index = 0
while index < number:
print("hello")
index += 1

repeat_hello(3)

so the function will be repeated 3 times

We dont define values to variables, we just define the variables and use it in funtion 

Parameter is the variable defined in the function

Example-

def greet(name):
print("hello there",name)


Argument is the values pssed to the function when its called

Example-
greet("Emily")


Concatenations means adding strings

Example-
Message="hello"+" "+"everybody"+"!"

In function we dont define the types of variables earlier, we define its type afer wrriting the variable

example-

def get_sum(first:int,second:int):

value = first + second
return value

s = get_sum(10,2)
print(s)


Example for repeating function 

def repeat(message:str,n:int)
msg=" "
index = 0
while index < n:
msg += message
index += 1

return msg
r = repeat("*",50)
print(r)

so this will print * 50 times

data structures

1. Lists
list is a collection of homogeneous items, new list can be created with brackets 
example-
my_list=[2,2,3,4,5]

Example-

values = [1,2,3,4,5]

names = ["Peter","Paul","Mary","Paul"]

The list shoukd have the same values 

print(values[0])

so the output will be 1

print(names[-1])

so the output will be paul


difference between string and list is that, with list we can assign values

Example-

names=["Peter","Paul","Mary","Paula"]

names[0] = "George""

print(names)

so the output will be- George, Paul, Marry, Paula
  

  indexing is similar to strings

  indexing items

  we use append to add any name at the end of the list

items can be added with functions append and insert

list.append(item) appends at the end of the list

list.insert(index, item) inserts into given index


example-

names = ["Peter","Paul","Mary","Paula""]

names.append("George")
names.append("John")

print(names)

so the output will have all the names and names of george and john at the end

We use insert to add a value at the beginning of the list

example-
numbers=[1,2,3,4,5]

numbers.insert(0,10)

print(numbers)

so the output will be-  10,1,2,3,4,5

The length of a list can be returned with len function

this works similarly to strings: it returns the number of items in a list

example-

numbers = [1,2,3,4,5,6,7,8,9,10]

index = 0
while index < len(numbers):
  print(numbers[index])
  index += 1

  so it will give all items in the list one at a time


  we can iterate the items in the list by using for loop

we use for loop because if there are more items in the list and until the condition is true it will select next item and store it in a variable and execute code block
  example-

  animals =["dog","cat","cow"]

  for animal in animals:
   print(animal)

for loop is used for iterating the items in the list

for loop also iterates the string

example-

name = "Peter"

for character in name:
  print(character)
output- P
        e
	t
	e
	r


Function range can be used to create an iterable sequence

This is handy if we want to iterate through a sequence, but do not need the list of values

example-

r = range(2,10)

for i in r:
 print(i)

 so it will print - 2,3,4,5,6,7,8,9

 example- for calculating the sum from 1 to 10001


 s = 0
 for i in range(1,10001):
  s += i
  print(s)

output- 5000500

example to get range as a list

 r = range(10,21)
 values = list(r)
 print(values)

 output - [10,11,12,13,14,15,16,17,18,19,20]



Method sort sorts the items "in place"

Function sorted returns a sorted copy of the list

  
  if the items in the list are not sorted then sort function makes the items in ascending order

example-

values = [10,2,3,5,7,9]

values.sort()
print(values)

output- [2,3,5,7,9,10]


also if the names are in the list then after sorting the list the names will be in alphabetical order 

list.sort() changes the items in the list in ascending / alphabetical order 

sorted(list) doesnt change the current list but it creates a copy of the list and makes it in ascending / alphabetical order

example-

names = ["Paul","George","Ringo"]

names_sorted = sorted(names):

print(names)
print(names_sorted)

output - ["Paul","George","Ringo"]
         ["George","Paul","Ringo"]

we can remove items from the list by using pop function. and if we dnt provinde the index of the item then it removes the last item from the list

example-

names = ["Paul","George","Ringo"]

names.pop()

print(names)

output-["Paul","George"]

if we provide index, for example-

names.pop(0)

then it willl remove the item at index 0, in above example the name "Paul" is at index 0, so it will be removed from the list

the second method is- we use "remove" o rmove an item.
syntax- listname.remove("itemname")

s from above example if we want to remove george names from the list 

names.remove("George")

print(names)

so ihe output will be all the names excluding George.

if we try to remove the name which does not exist in the list then we will encounter error

the content of the string cannot be changed once created.

to find number of words in a sentence we use count

Method count returns the number of items in a sequence

Method replace creates a new string with given substring replaced with another substring

example of count-

sentence = input("Give a sentence")

spaces = sentence.count(" ")
print(f"There are {spaces + 1} words in that sentence")

example for checking the ones in the list

values = [1,2,3,,4,1,1,1]

ones = values.count(1)
print(ones)

output - 4


If we want to replace items in the list we use- listname.replace("currentItemName","ReplacedName")

example-

sentence1 = "Red dog ran over a street"
sentence2 = sentence.replace("dog","cat")
print(sentence2)

output- Red cat ran oveer a street


The replace doesnt change the original string as after a string is created it cant be changed

so for replacing a string, we have to add it to another variable then replace it.

we can replace strings with other strings.

we use f-stings so that we can include variables in curly braces

example- 

name = "Emily"
age = 19
print(f"HI {name} your age is {age} years")

we can have nested lists

example-

matrix = [[1,2,3], [4,5,6], [7,8,9]]

print(matrix[0])

output- [1,2,3]

To access 1st item of 1st list from the matrix
we will write-

matrix = [[1,2,3], [4,5,6], [7,8,9]]

row1 = matrix[0]

first_item = row1[0]
print(first_item)

output- 1

another easy method to print the first item in the first row is-

print(matrix[0][0])

here the first[0] indicates the first list and thhe second[0] indicates the first item from that list.

we can acess all the rows in a matrix using for loop
example-

matrix = [[1,2,3],[4,5,6],[7,8,9]]

for row in matrix:
print(row)

output- [1,2,3]
        [4,5,6]
	[7,8,9]


to get items from a matrix, we use nested loop

for row in matrix:
  for item in row:
  print(item)

  output- 1
          2
          3
          4
	  5
	  6
	  7
	  8
	  9

To change a value into a list we need to assign the value to a variable 

example-

grades = [4,3,2,1]

grades[0] += 1

print(grades)

example2-

grades = [4,3,2,1]

for i in range(len(grades)):
  grades[i] += 1
 
 print(grades)

If we want to change all the items in the matrix we will use range

example- 
matrix = [[1,2,3],[4,5,6][7,8,9]]

for i in range(len(matrix)):
 for j in range(len(matrix[i])):
 matrix[i][j] += 1
 print(matrix)

 output-[[2,3,4],[5,6,7],[8,9,10]]

 so value of each item has been incresed by 1.

the i iterates through all  the indices and j iterates through all the items 

to check idices of each item -
example-

matrix = [[1,2,3],[4,5,6],[7,8,9]]

for i in range(len(matrix)):
 for j in range(len(marix[i])):
 print(f"i: {i}, j: {j}, value: {matrix[i][j]}")

output will be all the indices and its value

References

In python all variables are references 

the value of the variable is a reference object

variable doesnt contain the value, it contains a reference to that value, wwe can use the variable to access the object.

example-

a = [1, 2, 3]

b = a

a[0] = 10

print(b)

output- [10,2,3]

in above example we created a reference of a into b, so making changes in a affects b. so b will contain the changes made in a.


Example 2- 

a = [1, 2, 3]

b = a[:]

a[0] = 10

print(a,b)

output- [10,2,3] [1,2,3]

In the above example we have not given the reference of string a to b, instead we have copied the items of string a into b, and after that making changes in a doesnt affect b because a and b are the two separate lists.

we use a[:] for copying fromm one list to another.
syntax - list2 = list1[:]
this will copy all the contents from list 1 to list 2 

example of changing values by using function and passing reference to it instead of list


def increase_all(values: list):
    for i in range(len(values)):
        values[i] += 1

results = [5,2,4,7]
increase_all(results)  #function call
print(results)

output- [6,3,5,8]

example to check the second smallest item from the list

def second_smallest(values:list) -> int:
  values.sort()
  return values[1]


results = [9,7,5,8,6,3]

s = second_smallest(results)
print(s)

print(results)

output- 5
        [3,5,6,7,8,9]

in the above example sort is used for sorting the items in ascending order.

but if we dont want to sort the items and still find the second smallest item then we have to make a separate list and use sorted instead of sort.

example-

def second_smallest(values:list) -> int:
values2 = sorted(values)
return values2[1]

results = [9,7,5,8,6,3]

s = second_smallest(results)
print(s)

print(results)

output- 5
       [9,7,5,8,6,3]

 in the above example we gt the second smallest item from the list without changing its order an without changing the list.

In dictionary, all items consist of key-value pairs

Dictionary is useful (and fast) when we want to access values based on the keys
  
  dictionary dont have index number, means theres nohing like first item or last item, it has bunch of items, and each of those items has a key and a value. 
  example-

results = { "Paul": 9, "Peter": 6, "Paula": 10, "Jim": 6}

print(results["Paul"])

output- 9

Here the key and values is written in curly braces. example - {"Paul":9} so Paul is the key and 9 is the value in the dictionary.
there can be several items with same values but there must be separate key for all values.

if we want to print key and value then use "items" method. If we want to iterate through both, keys and values, we can use the method items.

syntax - for key, value in translations.items():
    print("key:", key)
    print("value:", value)

example-

students = {1234:"Peter", 2345: "Paul", 3456: "Oliver"}

for key,value in students.items():
print(key,value)

-----------------------------------

dictionary operates to access the data of single item.

but to change the data  of lots of items we use list.
 
-------------------------------------


Tuple-
A list-like data structure
Syntactical differences:
tuple is notated with parentheses (), list with brackets []
tuple is immutable means we cannot change anything.

Tuple is a collection of values that are connected. In tuple there is a collection of items of different types such as strings,integers.
 Tuples are mant for combining data together into a single object.



List is a collection of similar items, and the size (or order) may change. In List there are items of same type such as integer.
list are meant for storing similar kind of objects.

example of tuple-

student = ("Simon Williams",45,"simon@example.com")

example 2-


s1 =("Simon Williams",45,"simon@example.cm")
s2 =("Lisa Jones",99,"lisa@example.com")

students = [s1,s2]

for student in students:
 print(students[2])

 output- simon@example.com
        lisa@example.com
 
---------------------------------------

Part 6

we use "with" statement so that python automatically closes the file. it prvents from losing the data from the file.

we use "open" statement to open a file.syntax- with open("filename.txt") as file:

and we use "read" statement to read the file.

example-
with open("data.txt") as file:
conten = file.read() 
print(content)

output- it will give all the data in the file.

another method-

with open("data.txt") as file:
      for line in file:
      print(line)

It will print the file, line by line, and will include extra spaces.

itis like we have the extra space character at the end of each string

We use Strip method to remove the white spaces in the beginning and at the end og the string.
example-

with open("data.txt") as file:
  for line in file:
  line = line.strip()
  print(line)


we use line = line.replace("\n","")  
------------------------

CSV
Comma Separated Values

Several data points in one row, separated with suitable character (i.e. a separator)


String can be splitted into a list with the split method

The separator character is provided as an argument

example- 

string = "2,3,4,6"

values = string.split(",")
print(values)

output- ['2','3','4','6']

Split gives us data in the form of list.

Example 2-

s = "2,3,4,5"

values = s.split(",")
number = []
 for item in values:
 number.append(in(item))

print(sum(number))

output- 14

-------------------------------

CSV example-

Let There be a file named values.CSV

it consists of integers- 2,3
                         4,5,
			 6

code-
with open("values.csv") as file:
values = []
for line in file:
line = line.replace(""\n","")
items = line.split(",")

for item in items:
values.append(int(item))

print(values)

output- [2,3,4,5,6]

So it shows all the items in a file as a list.

To read te file more than ones we use seek method

example-

with open("Data.txt") as file:
 for line in file:
 print(line.replace("\n",""))

 file.seek(0)  #seek method takes back to the beginning of the file if we set seek to (0)

 for line in file:
 print("line.replace("\n",""))

 output- IT will print the contents in the file 2 times. 

---------------------------------------------

pass keyword does nothing.The pass keyword in Python is basically a placeholder. It does nothing when it’s executed — it's used when the syntax expects a statement but you don't want to write any code yet.
You usually use pass when:
You're building out the structure of your code but haven't implemented the details yet.
You need a class, function, or loop to exist without doing anything for now (to avoid syntax errors).
-----------------------------------------------

When we open a file in "w" mode (w stands for write) in Python, here’s what happens:
If the file doesn't exist, Python will create a new file for you.
If the file already exists, Python will erase all the contents (truncate it) and start fresh.

and we write in a file using "wrie" method- file.write("content")


example-
with open("example.txt", "w") as file:
    file.write("Hello, world! \n")
     file.write("I am ABC \n")

example 2 - for taking input from user to write in a file-


with open("result.txt", "w") as file:
 while true:
  line = input(""Give a line, empty stops:")
  if line == "":
  break
  file.write(line + "\n")

-----------------------------------------------
When we open a file in 'a' mode:
 If the file doesn’t exist, Python creates it (just like 'w' mode).
If the file already exists, Python keeps the existing content and adds (appends) the new data at the end of the file — without deleting anything.
example- 
with open("example.txt", "a") as file:
    file.write("\nThis is a new line!")

-----------------------------------------------
example- of string.

data = [1,2,3,4,5,6,7,8,9]

 with open("result.txt","w") as file:
 s = ""
 for item in data:
 s += str(item)
 s += ","
s = s[:-1]

 file.write(s)

output- 1,2,3,4,5,6,7,8,9

----------------------------------------------
 In Python, join() is a string method that joins (combines) a list (or any iterable) of strings into one single string, with a separator that you choose.

 syntax- separator.join(iterable)

separator is what you want between the items (like a space, comma, dash, etc.) iterable is usually a list or tuple of strings.

Example 1: Joining words with spaces

words = ["Hello", "world", "Python", "rocks"]
sentence = " ".join(words)
print(sentence)

output-  Hello world Python rocks

Example 2: Joining with commas
    
items = ["apple", "banana", "cherry"]
csv = ",".join(items)
print(csv)

output- apple,banana,cherry

-----------------------------------------------
The os module in Python is a built-in module that lets you interact with the operating system — like dealing with files, folders, environment variables, and more.

Task with example-
Get current working directory - os.getcwd()
Change directory - os.chdir('path/to/folder')
List files and folders - os.listdir('path')
Create a new folder - os.mkdir('folder_name')
Remove a folder - os.rmdir('folder_name')
Remove a file - os.remove('file_name')
Check if a file/folder exists - os.path.exists('path')

example- 
import os

# Get current working directory
print(os.getcwd())

# Make a new folder
os.mkdir("new_folder")

# List contents
print(os.listdir())

----------------------------------------------

try → Try to run some code.

except → If there’s an error, catch it and handle it nicely.
example-
try:
    num = int(input("Enter a number: "))
    print(10 / num)
except ValueError:
    print("That's not a number!")
except ZeroDivisionError:
    print("Cannot divide by zero!")

ValueError happens if you enter a letter.
ZeroDivisionError happens if you enter 0.

example2 - 

try:
    age = int(input("What is your age? "))
    print(f"You are {age} years old.")
except ValueError:
    print("Please enter a valid number for your age!")

Here 
int(input(...)) tries to convert the input to an integer.

If the user types something that can't be converted (like "Twenty"), it raises a ValueError.

The except block catches that and shows a friendly message instead of crashing.


Typical exceptions
ValueError
TypeError
IndexError
ZeroDivisionError
Exceptions in file handling

we must always have an except statement which specifies the type of error.
----------------------------------------------

factorial of a number using function example-

def find_factorial(n: int) -> int:
if n < 0:
        return "Factorial not possible for negative numbers."
    elif n == 0:
        return 1
    else:
        fact = 1
        for i in range(1, n + 1):
            fact *= i
        return fact

number = int(input("Enter a number: "))
result = find_factorial(number)
print(f"Factorial: {result}")
----------------------------------------------
The raise keyword in Python is used to raise an exception (i.e., trigger an error) manually. It allows you to intentionally stop the normal flow of the program and indicate that something went wrong.


syntax example- raise Exception("Error message")

Exception: This is the type of error you're raising (you can use a built-in exception type, like ValueError, or create your own custom exceptions).

"Error message": This is the message that provides information about the error.

------------------------------------------------
A local variable is a variable that is defined inside a function and is only accessible within that function. Once the function execution finishes, the local variable is destroyed and can no longer be accessed outside of it.

example - 
def my_function():
    x = 10  # x is a local variable
    print(f"Inside the function: x = {x}")

my_function()

# Trying to access x outside the function will raise an error
# print(x)  # This would cause an error since x is not accessible here

-------------------------------------------------
A global variable is a variable that is defined outside of any function, and it is accessible from any function in the program. Global variables have a global scope, meaning they can be accessed and modified anywhere in the program after they are defined.
They are defined outside all functions (usually at the top of your script).

They can be accessed by any function in the program, making them globally accessible.

To modify a global variable inside a function, you need to use the global keyword.

example-
x = 5  # This is a global variable

def print_global():
    print(f"The global variable x is: {x}")

print_global()

output- The global variable x is: 5


modifying a global variable inside a function-

 to modify a global variable inside a function, you must explicitly use the global keyword. Without it, the function will create a local variable with the same name and will not modify the global variable.

example-

x = 5  # Global variable

def modify_global():
    global x  # This tells Python we're using the global variable x
    x = 10

modify_global()
print(f"After modification, global x is: {x}")

output- After modification, global x is: 10


---------------------------------------------------

part 7-

Modules 
Modules are Python files that contain reusable code (functions, classes, etc.).
You can import and reuse these modules in different parts of your program.
The standard library of Python contains several useful modules,you can also create your own modules.
We have earlier used for example module math to calculate square roots

we have to import modules with "import" statement.

example-

import math

number = 9

print(math.sqrt(number))

output- 3.0

another method

example2-

from math import sqrt

print(sqrt(49))

output- 7.0


----------------------------------------------

Standard library modules are described in Python documentation

Operations can be listed with the function dir
hen you import a module and call dir() on it, it shows you the available attributes and functions within that module.

example-
import math

# List all the functions and attributes available in the math module
print(dir(math))

in the output it will show all the function of math module.


Types of modules-

1. Random
Module random can be used to generate pseudo random numbers

example-

import random

print(random.randint(1,6))   #here 1 to 6 is inclusive, any number from 1 to 6 will be picked randomly

we can also run this in a loop 
example-
import random

for i in range(10):
 print(random.randint(1,6))

 output- it will give 10 numbers randomly from 1 to 6 

It works same for Lists.

example-

import random

names = ["Paul", "Peter", "Paula", "Bob"]

for i in range(4):
print(random.choice(names))

output- random names


2. random.sample gives us unique elements from a list,string. It gives multiple elements without repetition.

3. random.shuffle is part of the random module and is used to randomly shuffle the elements of a list in place. Unlike random.sample(), which returns a new list, random.shuffle() modifies the list directly and does not return a new list.


4. datetime

A datetime object represents a combination of a date and a time

example- 

from datetime import datetime 

now = datetime.now()

print(now)


The timedelta class represents the difference between two datetime objects (a duration).

example- 

from datetime import datetime

now = datetime.now()

# Create a timedelta of 5 days
five_days = timedelta(days=5)

# Add 5 days to the current date and time
now = now + five_days
print("Date after 5 days:",now)


datetime object can be formatted with the strftime function. It isused if we want only a specific format. such as month,year,date,time.

%d - Day (01-31)
%m - Month (01-21)
%Y - Year (YYYY)
%H - Hour (24h format)
%M - Minutes 00 to 59
%S - Seconds 00 to 59

syntax- 
datetime.strftime(format)

example-

from datetime import datetime

now = datetime.now()

print(now.strftime("Today is %d. day of %m. month in %Y"))

output- Today is the 19 day of 10 month in 2023.


5. CSV Module-
The csv module provides functionality for reading from and writing to CSV (Comma Separated Values) files. It is part of the Python standard library and is used to handle CSV files with ease. CSV files are commonly used to store tabular data, such as spreadsheets or database exports.

6. urllib.request module is used for reading web page (as HTML).


we can create our own modules.
Any Python program that contains functions can be used as a module.

we have to just import the python module file that we created. 

example of calculator moodule-
# calculator.py

def add(a: int, b: int):
 return a + b

def sub(a: int, b: int):
 return a - b


import the above module calculator.py in our code. 

Main Program 
if module contains program code outside functions, it is always executed when the module is imported

This can be prevented by including code inside if __name__ == "__main__" block

----------------------------------------------

Simple if-else conditions can be writen with as a single expression

example-

print("Even" if x % 2 == 0 else "odd")

It works same as 
if x % 2 == 0:
  print:("Even")
else:
  print("Odd")
-------------------------------------------------
Default Parameter Value

Function parameters can be provided default values
In such cases, the argument may be omitted when calling the function

default values means we can provide the value to the functin but if we dont provide then the function uses its own value.

---------------------------------------------
Changing number of parameters
The parameter number can be defined as changing by typing an asterisk in front of parameter name


* is used for capturing multiple elements in a list or tuple unpacking.

------------------------------------------------------------------

Part 8-

OBJECT ORIENTED PROGRAMMING

Objects-
Objects are independent.Objects are used to model real-world entities, helping in organizing and managing code.
An object is an instance of a class. A class is a blueprint for creating objects, and each object has its own state (attributes) and behaviors (methods).

For example, consider a Car class. When you create a specific car, like my_car, that car is an object of the Car class.


Methods-
A method is a function that is defined inside a class and is associated with an object of that class. Methods define the behavior of the objects created from the class.
Mehtods are always inside the class.

Methods can access and modify an object's attributes. The first parameter of every method is self, which refers to the instance of the object (the object calling the method).
Methods define the behaviors or actions that objects can perform, enabling reusability, maintainability, and clean organization of code.

Example of objects-

book = { "author": "J.K.Rowlings", "title": "Harry Potter"}

print(book.keys())

print(book.values())

output- dist_keys(['author', 'title'])
        dist_values(['J.K.Rowlings', 'Harry Potter'])



Example of Methods-
class Car:
    def __init__(self, make, model):
        self.make = make
        self.model = model
    
    def start_engine(self):
        print(f"The {self.make} {self.model}'s engine is now running.")
    
    def stop_engine(self):
        print(f"The {self.make} {self.model}'s engine is now off.")
--------------------------------------

Creating OBJECTS-

lists are declared with square brackets
example-  my_list = [1,2,3]

strings are declared with quotation marks
example- my_string = "Hi there!"

dictionaries are declared with curly brackets
example- my_dict = {"one": 1, "two": 2}

tuples are declared with parentheses

my_tuple = (1,2,3)

----------------------------------------

Constructor-
It is the basic way of generating objects out of a class. It is used to initialize an object when its created. when we make a new object from a class, the constructor sets it up- ggiving it initial values,preparing it to be used.

example-
class Dog:
    def __init__(self, name):
        self.name = name

# When you create a Dog object, the constructor (__init__) runs:
my_dog = Dog("Buddy")
print(my_dog.name)  # Output: Buddy

In this case, __init__ is the constructor — it sets the dog's name when you create it.


-----------------------------------------
Class is the blueprint of the object

Classes define the structure and functionality of objects

It is (usually) possible to create several objects out of a single class


Attribute is a variable belonging to certain object.
We can have same naming atributes for multiple objects

Methods are always inside the class.
---------------------------------------

Example2 of objects-

Class Book:
pass

 novel1 = Book()
 novel1.author = "Ernest Heningway"
 
 novel2 = Book()
 novel2.author = "J.K.Rowling"
 print(novel1.author)
 print(novel2.author)


 #here author is the attribute and novels are the objects in Class Book.

 -----------------------------------------

 Defining a constructor-
we define a function in class.
function for constructor is called __init__

when we are defining a method the first parameter is called self.this self parameter is used to access the content of the object.


example-

class Book:
 def __init__(self, author: str, title: str, pages: int)

 self.author = author
 self.title = title
 self.pages = pages
 self.year = 2023
 self.on_sale = False

 b = Book("Steinback", "Grapes of wrath", 489)
 b2 = Book("J.K.Rowling", "Harry Potter", 999)
 
print(b.author)
print(b.on_sale)

books = [b,b2]

for book in books:
print(book.tile)

Output- it outputs the attribute values
output is- Steinback
            False
            Grapes of wrath
	    Harry Potter

-------------
By Using __str__ function we can get all the attributes of the object.
syntax-   def __str__(self):
return f*Book(author={self.author}, title={self.title}, pages={self.pages})"

s = b.__str__()

print(s)
we will get information about book.
Output - Book(author=Steinback,title= Graph of wrath, pages= 489)
----------------------------------------------

Terminology

Client is the program code who is using the class

Encapsulation means hiding the implementation from the client

Ensuring the internal integrity of the class

--------------------------------------------------
Part 9

__repr__ function gives the string representation of the object.
syntax- def __repr__(self):

--------------------------------------------
The Items stored in data structure are actually references to items.

We can use objects as parameters.
Variable self can be used to references the object itself.


Example of passing a list of objects as parameters-
def add_item(my_list):
    my_list.append("new item")

items = ["apple", "banana"]
add_item(items)

print(items)

output-['apple', 'banana', 'new item']
 

items (a list object) is passed into add_item.

The function modifies the original list because lists are mutable.

-----------------------------------------

Objects as attributes- Objects can be stored inside other objects.


----------------------------------------------

Keyword "None" denotes an empty reference. It doesnt have any value.

----------------------------------------
Encapsulation

Object offers servics to the client so that

1) utilizing class and object is as simple as possible for the client and
2) the internal integrity of the object is preserved in all situations.

Hiding attributes
Class can hide attributes from the client
This is done by writing a double underscore in front of the attribut name.

example- self.__credits

So if we try to access it then it will give us error stating that there is no attribute.

Getters and setters 

When we want to provide the client(a limited) access to some of the attributes we use getters and etters.

If an access to hidden attribute should be provided, special getter and setter operations can be provided for the client
it is also possible to just offer one of these, if only read or write access is needed.

example-
class Person:
    def __init__(self, name, age):
        self._name = name  # Using a leading underscore to indicate "protected" attribute
        self._age = age

    # Getter for name
    def get_name(self):
        return self._name
    
    # Setter for name
    def set_name(self, name):
        if isinstance(name, str):  # Check if the name is a valid string
            self._name = name
        else:
            print("Name must be a string!")

    # Getter for age
    def get_age(self):
        return self._age

    # Setter for age
    def set_age(self, age):
        if isinstance(age, int) and age > 0:  # Check if age is a positive integer
            self._age = age
        else:
            print("Age must be a positive integer!")

# Creating an object of Person
person = Person("Alice", 30)

# Using getter methods to access attributes
print(person.get_name())  # Output: Alice
print(person.get_age())   # Output: 30

# Using setter methods to modify attributes
person.set_name("Bob")
person.set_age(35)

print(person.get_name())  # Output: Bob
print(person.get_age())   # Output: 35

# Trying to set invalid data
person.set_name(123)  # Output: Name must be a string!
person.set_age(-5)    # Output: Age must be a positive integer!

Key points-
Getter methods return the value of an attribute.

Setter methods modify the value of an attribute, and typically include validation to ensure that the new value is appropriate (for example, checking data types or ranges).

The leading underscore (_name, _age) is a convention indicating the attribute should not be accessed directly but through the getter and setter methods.

Example 2- Using Example 2- Using @property and @setter

class Student:

 def __init__(self,name:str, id: str, credits: int):
  self.name = name
  self.id = id
  self._credits = credits


@property

def credits(self):
 return self._credits + 5

 @credits.setter
 def credits(self, new_credits: int):
 self._credits = new_credits

 s1 = Student("Simon","1234",55)


 print(s1.credits)

s1.credits = 100

print(s1.credits)

Output- 60
        105

--------------------------------------------------

Method Visibility

Two underscores before mthod name hides the method from the client.
example-

class Recipient:

 def __init__(self,name: str, email: str):
 self.__name = name
  if self.__check_email(email):
  self.__email = email
else:
 raise ValueError("The email address is not valid")

def __check_email(self,email: str):

#A simple check: the address ,ust be over 5 characters long and contain a dont and an @ character

return len(email) > 5 and "." in email and "@" in email


------------------------------------------------

Static members

Class members are called static members. These include - class variables and class methods.

We write a vaiable in Capital letters so that it is a constant value.

static members (or static variables) are variables that are shared among all instances of a class. They are defined within a class, but they are not tied to any specific instance of the class. They can be accessed using the class name or an instance of the class.

We write a static variable inside a class but outside a object. so it can be shared to all instncs of class.

we access it by class variable name.

--------------------------------------------
 without creating object we can access a class method.
instead of self we use cls as first parameter.
 example-

@classmethod
def output_school_name(cls):
 print("University of Helsinki")

 student.output_school_name()

 output- University of Helsinki



Example2- 
#A class method for validating the license plate

@classmethod

def license_plate_valid(cls,plate:str):
  if len(plate) < 3 or "-" not in plate:
  return False

  #Check the begining and end section of the plate separately

  letters,numbers = plate.split("-")

  #the beginning section can have only letters

  for character in letters:
   if character.lower() nnot in "abcdefghijklmnopqrstuvwxyz"":
   return False

   #the end section can only have numbers

   for character in numbers:
   if character not in "1234567890":
   return False

 return True


-------------------------------------

